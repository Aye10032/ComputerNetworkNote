# 3.4 流量控制与可靠传输机制

## 3.4.1 流量传输概述

- 数据链路层
  - 流量控制是点对点的
  - 方法：接收端收不下就不发送确认
- 传输层
  - 流量控制是端到端的
  - 方法：接收端给发送端一个窗口公告

### 1、可靠传输与流量控制

**可靠传输**：发送端发送什么，接收端就接收什么

**流量控制**：控制发送速率，使接收方有足够的缓冲空间来接收每一个帧

### 2、滑动窗口机制

解决可靠传输：发送方自动重传

解决流量控制：在没有收到窗口确认的情况下不发送下一个

## 3.4.2 停止-等待协议

### 1、停止-等待协议概述

“停止-等待”就是每发送完一个分组就停止发送，等待对方确认，在收到确认后再发送下一个分组。

#### 为什么要有停止-等待协议

- 除了比特出差错，底层信道还会出现丢包问题
- 为了实现流量控制

#### 研究停等协议的前提

以半双工的形式进行讨论

不考虑数据是在那一层进行传输的

#### 停等协议有几种情况

- 无差错情况
- 有差错情况

### 2、无差错情况

![无差错停等协议](../.gitbook/assets/无差错停等协议.png)

每一帧就停止等待，所以仅需要一位对帧进行编号。

### 3、有差错情况

#### （1）帧丢失或帧出错

![停等协议帧丢失](../.gitbook/assets/停等协议帧丢失.png)

- **超时计时器**：每次发送 一个帧就启动一个计时器
  - 计时器的重传时间比平均传输往返时延（RTT）稍长一些
- 发送一个帧之后需要**保留副本**
- 数据帧和确认帧必须**编号**

### 2、ACK丢失

![停等协议ACK丢失](../.gitbook/assets/停等协议ACK丢失.png)

### 3、ACK迟到

![](../.gitbook/assets/停等协议ACK迟到.png)

接收方判断到重复的确认帧时就将其丢弃

### 4、停等协议的信道利用率

![停等协议信道利用率](../.gitbook/assets/停等协议信道利用率.png)
$$
\begin{align}
\text{信道利用率U}&=\frac{\text{T}_{D}}{\text{T}_{D}+\text{RTT}+\text{T}_{A}}\\
&=\frac{\text{L/C}}{T}\\
信道吞吐率 &= 信道利用率 \times 发送方的发送速率
\end{align}
$$

- $$\text{T}_{D}$$：数据帧的发送时延
- $$\text{RTT}$$：往返时延
- $$\text{T}_{A}$$：确认帧的发送时延
- L：T内发送L比特数据
- C：发送方的数据传输率
- T：发送周期

可见停等协议的**信道利用率较低**。

{% hint style="info" %}

设一个信道数据传输率为4kb/s，单向传播时延为30ms，若使用停止-等待协议的信道最大利用率为80%，则数据帧的长度至少为多少？

$$80\% = \frac{\text{L}/4}{\text{L}/4 + 2 \times 30}$$

解得 L=960bit/s

{% endhint %}

## 3.4.3 多帧滑动窗口——后退N帧协议（GBN）

![GBN](../.gitbook/assets/GBN.png)

与停等协议相比，GBN：

- 需要更大的编号范围
- 发送方需要缓存多个帧

#### GBN中的滑动窗口

发送方有**多个窗口**，而接收方只有**一个窗口**

![GBN窗口](../.gitbook/assets/GBN窗口.png)

- 发送方会依次发送发送窗口内的帧
- 接收方收到后发送确认帧，发送方和接收方的窗口各自向前移动
- 可以只发送最后一个确认帧，代表前面的帧都接收到了
  - 例如发送了3号确认帧，代表0、1、2、3号帧都收到了，窗口各自向前移动4格
